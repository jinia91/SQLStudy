# 시야 협착 회피하기
>  망치라는 도구만을 가진 사람에게는 모든 문제가 못으로 보인다.<br>
> \- Abraham Harold Maslow

## 시나리오
     1. 주문 테이블이 존재하며, 주문테이블의 컬럼에는 주문 생성날짜, 배송 도착 예정 날짜가 존재.
     2. 주문이 생성될 때, 주문 생성날짜와 배송 도착 예정 날짜가 레코드로 삽입
     
     3. 배송 도착 예정 날짜는 수시로 변경될 수 있음
     
     4. 요구사항 : 배송 도착 예정날짜 - 주문 생성날짜의 값이 3일 이상일경우 배송이 늦어진다는 표시
    

## SQL 을 통한 해결책

간단한 요구사항이므로 모든 주문에 대해 `배송 도착 날짜 - 주문 생성날짜`가 포함된 쿼리를 날리면 된다.

> select order_id, delivery_date - order_date as diff_days <br>
> from order <br>
> where delivery_date - order_date >=3;

## 시나리오 + 문제상황

    전제 조건 : 현재 데이터가 1억개 존재하고, 애플리케이션의 daily page view가 1억
    
    추가 요구사항 : 전체 주문에대한 지연상황을 실시간으로 메인화면에 띄워야함
    
    
    
위의 전제 조건과 추가 요구사항을 고려하면 1억건 데이터를 가진 테이블 전체를 하루에 1억번 sql을 통해 연산을 하며 데이터 조회를 해야한다.

이런 시나리오에서 sql 조회만을 통한 해결책보다 효율적인 방식은 없을까?

## 테이블 변경 + 배치를 통한 해결

단순히 order 테이블에 status 컬럼을 추가하고, 해당 컬럼에 delivery_delay 라는 레코드를 집어넣을수 있다고 생각해보자.

최초 데이터 insert시 지연에대한 정보를 넣어주기때문에, 조회시 연산을 빼고 배송이 지연되는 데이터만 조회가능하므로 보다 나은 조회가 가능하다.

문제는 시나리오상의 `배송 지연 날짜는 수시로 변경될 수 있음` 인데, 

이부분은 배치작업을 통해 일정 시간마다 변경 데이터를 갱신해줌으로서 실시간성에 대해 일정부분 포기하고, 성능을 챙기는 트레이드 오프 지점이다.

따라서 업무의 요구사항, 기획에 따라 적절히 판단하자.

## 핵심은 넓은 시야

위의 시나리오에서 sql을 통한 솔루션과 테이블 변경 + 배치작업을 통한 솔루션 둘다 이상적인 해결책은 아니다.

둘 사이에는 실시간성과 성능의 트레이드오프가 존재하고 이부분은 문제의 세부 요구사항에 따라 얼마든지 달라질 수 있다.

여기서 핵심은 문제상황을 맞닿뜨렸을 때, 익숙한 사용도구만을 가지고 해결하려는 `시야 협착` 에 빠지지말고 다양한 관점에서 접근하라는 것!

# Index

[인덱스 기본 개념](https://www.jiniaslog.co.kr/article/view?articleId=505)

## 인덱스를 잘 활용하려면

인덱스를 쓰면 마법처럼 성능이 개선된다고 믿지 말라

> No Silver Bullet - Essence and Accident in Software Engineering
> - 프레드 브록스 , 맨먼스 미신

### 카디널리티와 선택률

1. 카디널리티(cardinality)
    필드에 들어있는 값의 갯수. 카디널리티가 가장 높다면 모든 레코드에 다른 값이 들어있는 UK라는 뜻이며, 카디널리티가 가장 낮다면 모든 레코드에 동일 값이 들어있다는 의미
2. 선택률
    필드에서 특정 값을 조회할때, 테이블 전체에서 몇개의 레코드가 선택되는지를 나타내는 개념

### 인덱스가 Full table scan보다 더 빠를 기준?

>카디널리티가 높고, 선택률이 낮아야한다.

구체적 역치는 선택률이 10% 미만일때가 이상적

만약 10% 이상이라면 full table scan이 더 나은 선택일 수 있다.

## 인덱스를 사용하기 어려운 상황

### 1. 압축 조건이 없는 경우

    select id, name from table

반드시 모든 테이블을 조회해야하는 상황이므로, 어쩔수가 없다.

### 2. 레코드 압축이 어려운 경우

(1) 선택률이 높은상황

    select * from order where status = delivery
    
위의 상황에서 order테이블의 80%가 delivery 상태라고 가정해보면 status에 인덱스를 생성하는것은 오히려 성능 하락을 가져올 수 있다.

만약 delivery 상황이 매번 변동하여 어떤날은 5% 미만, 어떤날은 80%와 같이 변동될 경우 옵티마이저가 선택률이 낮은날엔 인덱스를 사용하면 이상적이나 이렇게 작동하길 기대하긴 어렵다.

### 3. 인덱스 사용 불가능 쿼리

- `like %string`
- `like %string%` 
- 인덱스 컬럼에 연산이 들어간경우
    - index_column * 1.1 > 100
    - length(index_column) = 10
- 부정형을 사용하는 경우
    - index_column <> 100


## 인덱스 사용이 어려울때 해결법

### 1. 비정규화

> 필요로 하는 데이터만을 따로 인덱스가 가능한 비정규화 테이블로 생성하고 해당 테이블을 조회하는 방식

단점

- 데이터 동기화 문제
    원본 데이터를 복사하여 비정규화 테이블을 새로 생성하고 갱신해야하는 만큼, 갱신 부하 부담과 갱신 빈도에대해 고려해야한다.
- 비정규화 테이블 크기
    해당 방식은 필요로 하는 데이터만큼 테이블을 줄여 I/O 부담을 줄이고 인덱스가 가능하게끔 하는것이 목적이므로 만약 필요로하는 데이터가 너무 크다면 큰 의미가 없다.
- 관리포인트 증가
    중복 테이블이 증가하는셈이므로 관리포인트가 증가하고 유지보수가 어려워진다

### 2. 인덱스 온리 스캔
> 조회 조건 전체를 커버할수 있는 다중 컬럼 인덱스를 만드는 방식

인덱스에 대한 조회는 full index scan이 아닌 이상 b+tree 자료구조를 사용해 데이터 접근을 하므로, 일반적인 table scan에 비해 훨씬 빠르다.

따라서 인덱스 자체에 조회에 필요한 모든 데이터 컬럼을 포함시키고 인덱스 서치를 통해서만 조회하게끔 하면 성능 향상을 이룰 수 있다.


단점

- 한개의 인덱스에 포함할 수 있는 필드수 제한(길이 제한)이 존재
- 갱신 오버헤드 증가
- 정기적인 인덱스 리빌드가 필요(유지관리해야함)
- 새로운 필드가 추가될경우 사용불가

 
