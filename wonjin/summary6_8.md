# 기능적 관점으로 Join 분류

## 크로스 조인(cross join)

* 모든 결합의 모체
* N \* M 의 카티션 곱을 그대로 출력
* 하지만 실무에서 사용할일은 적음
    * 왜냐면 크로스 조인을 하는 데이터가 필요할 일이 거의 없기 때문
* 카티션곱의 조인을 실수로 사용하지 않기 이해서라도, `on`을 사용해 inner join을 하기를 추천

## 이너 조인(inner join)

* 카티션 곱의 부분집합
* 카티션곱으로 만들어진 테이블에서 `on` 조건에 충족되는 데이터만 출력한것이라고 보면됨

## 아우터 조인(outer join)

* `outer`인 이유는 카티션 곱의 외부데이터가 들어갈 수 있기 때문!
* 마스터가 되는 테이블의 모든 정보를 보존하고자 null을 생성하기 때문에 카티션 곱 이외의 데이터도 존재하게 된다.

# Join 알고리즘과 성능

* Nested Loops
* Hash
* Sort Merge

> mysql은 8.0 이상 버전부터 join시 Hash 알고리즘 사용가능, aws aurora DB도 최신버전은 Hint구문을 사용하면 가능하다고함

## Nested Loops

* 사실상 2중 for 문
* 구동테이블(outer table)을 기준으로 내부테이블(inner table)에 순차적으로 접근하며 2중 for문을돌고 조건에 맞는 데이터를 join하는 방식
* 가장 일반적인 join 알고리즘

### Nested Loops 성능 개선 - Inner Table Index!

* 데이터 큰테이블을 inner table로 잡을것!
* outer 테이블은 필연적으로 모두 접근해야하므로,Full table scan을 피할수 없으나, inner table은 조건에 맞는 데이터를 탐색하므로 **결합키에 index가 걸려있으면** index 활용이 가능하다.
* 따라서 데이터가 큰 테이블을 Inner table로 삼고 index를 잘 사용하면 극적인 성능 향상을 달성할 수 있음

### 성능 개선이 힘든 상황

> 결합키의 유일성이 보장되지 않아, 인덱스 탐색시 중복히트가 너무 많이 발생하는 경우

* 이때는 만약 데이터가 적은 테이블(`현재 구동테이블`)의 결합키가 유일성을 보장한다면, 역설적으로 데이터가 적은 테이블을 inner table로 바꿔보는것도 좋은 시도
* Hash Join 사용하기

## Hash

* mysql 8 이상부터 지원
* 데이터가 작은 테이블을 기준으로 결합키를 사용해 메모리상의 해시테이블을 만들고, 큰 데이터 테이블을 순회하며 결합키에 해당하는 해시테이블에 선형접근(O(N))하여 join 시키는 알고리즘
* 메모리에 해시테이블을 만들어야 하므로, 메모리가 부족하면 디스크를 사용하는 페이징이 일어나고(`temp`) 지연발생
* 해시값은 순서를 알지는 못하므로, 등치 결합(`on(a.~~=b.~~)`)에만 사용 가능
* nest loops 알고리즘사용시 inner table에서 히트되는 레코드 수가 너무많거나 인덱스가 존재하지 않을때 좋은 대안이 된다.

## Sort-Merge

* mysql은 지원 x
* join 할 양 테이블을 각각 메모리상에 띄워 결합키를 기준으로 정렬하고, 매칭되는 결합키에 맞게 join시키는 방식
* 정렬을 통해 join하므로, 부등호 결합에도 사용가능하며, 테이블이 결합키로 정렬되있다면, 정렬 생략이 가능

## 소결

| 이름 | 장점 | 단점 |
| --- | --- | --- |
| Nested Loops | \- 작은 구동 테이블 \+ 인덱스 내부테이블시 성능이 좋고 제약이 적음 | 대규모테이블끼리의 join시엔 부적합하고 인덱스가 없으면 비효율적 |
| Hash | 대규모 테이블간 결합시 유용 | 메모리 소비량이 큼, 등가 결합밖에 안됨 |
| Sort Merge | 대규모 테이블간 결합시 유용 | 메모리 소비량이 매우 큼 |

* 기본적으로는 Inner table 결합키에 Index를 건 Nested Loops, 잘 안되면 Hash

# 서브 쿼리

## 서브 쿼리의 문제점

### 연산 비용

* 임시테이블을 만들고 그 테이블을 조회하는 방식이므로 매 쿼리마다 연산비용이 추가

### 데이터 I/O 발생

* 위의 이유로 사실상 추가적인 쿼리를 더 날리는셈이고 I/O가 일어남

### 최적화가 불가능

* 대표적으로 인덱스를 걸수 없기 때문에, 최적화가 불가능

## 해결책

### 윈도우 함수 사용

> 기존의 RDBMS는 칼럼과 칼럼의 연산은 쉬운 반면 행과 행의 관계를 연산하거나 정의하는 일은 굉장히 어려운 문제였다. 따라서 이러한 문제를 쉽게 해결할 수 있도록 제시된 것이 WINDOW FUNCTION이다.

* 튜플간의 연산을 쉽게 해주는 함수로 윈도우 함수를 이용하면 순위, 합계, 평균, 행 위치 등을 조작할 수 있다.
* mysql 8버전 이상부터 지원

### 서브쿼리가 더 나은 경우도 존재한다

* join과 집계함수를 동시에 써야하는 상황에서 Join 연산을 줄이기 위해 선 집계후 해당 집계 테이블을 서브쿼리로 Join하는 상황

# 레코드에 순서 붙이기

## 단순 id 정렬시

### 윈도우 함수 사용

* row\_number()

### 상관 서브쿼리(select 서브쿼리)사용

> select id, (select count(\*) from table t2 where t2.id <= t1.id) from table t1

## 다중키로 정렬시

### 윈도우 함수 사용

* row\_number() over(column1, column2)

### 상관 서브쿼리 사용

> select column1, column2, (select count(\*) from table 
> t2 where (t1.column1, t2.column2) 
> <= (t1.column2, t2.column2)) from table t1

## 그룹마다 순번붙이는 경우

### 윈도우 함수 사용

* row\_number() over (partition by column1 order By column2)

### 상관 서브쿼리 사용

> select column1, cloumn2, (select count(\*) from table t2 where t1.column1 = t2.column2 
> and t1.column2 <= t2.column2) from table t1

## generate Id 전략

* Sequence
* Identity
* table

### Sequence

* DB 스키마 내부에 존재하는 Sequence객체를 사용(view, table 등과 동등한 객체)
* mysql은 사용 불가능
* `nextVal`사용
* 성능상 문제가 존재

#### 성능상 문제점

* 유일성, 연속성, 순서성을 만족시키기 위해 Beta Lock을 사용
* 따라서 동시에 여러 사용자가 시퀸스 객체에 접근하는 경우 락 충돌로 인해 성능 저하 문제가 발생
* 시퀸스 객체가 저장된 디스크에 잦은 조회가 일어나는데, 이때 hot spot 이슈가 발생
* jpa로 구현시 시퀸스로부터 id를 가져오기위해 네트워크를 추가로 타는 이슈 존재

#### 성능 문제 해결법

* cache로 미리 채번
* `noorder`옵션으로 순서성 담보를 포기하고 성능 향상

### Identity 필드

* id 값을 null로 하면 DB가 알아서 AUTO\_INCREMENT
* 자동 순번 필드라고도 불리우며, 테이블마다 개별적으로 종속되어 작동함
* 성능적으로는 sequence객체보다도 비효율적
    * 튜닝방식도 존재하지 않음
    * jpa상에서 bulk insert 사용 불가능(`1만튜플 insert 기준 성능은 약 2배정도 차이`)

### table 방식

* 시퀸스 객체가 아닌 시퀸스 테이블을 통해 시퀸스 객체의 메커니즘을 흉내내는방식
* 시퀸스 객체에 비해 최적화된 방식이 아닌 흉내내는방식이므로 성능상 문제가 있음
* 실제 프로덕트 레벨에서는 추천되지 않음
